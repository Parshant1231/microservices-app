name: Build and Deploy to AWS EC2

on:
  push:
    branches:
      - main

env:
  IMAGE_FRONTEND: ${{ secrets.DOCKER_USERNAME }}/myapp-frontend
  IMAGE_BACKEND: ${{ secrets.DOCKER_USERNAME }}/myapp-backend

jobs:

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 1: BUILD & PUSH IMAGES TO DOCKER HUB
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  build:
    name: Build & Push Docker Images
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and Push Frontend
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: true
          tags: |
            ${{ env.IMAGE_FRONTEND }}:latest
            ${{ env.IMAGE_FRONTEND }}:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and Push Backend
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: |
            ${{ env.IMAGE_BACKEND }}:latest
            ${{ env.IMAGE_BACKEND }}:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 2: DEPLOY TO AWS EC2
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  deploy:
    name: Deploy to AWS EC2
    runs-on: ubuntu-latest
    needs: build

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: SSH and Deploy
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |

            # â”€â”€ STEP 1: Install Docker if not already installed â”€â”€â”€â”€
            if ! command -v docker &> /dev/null; then
              echo "Docker not found. Installing..."
              sudo apt-get update -y
              sudo apt-get install -y ca-certificates curl gnupg

              sudo install -m 0755 -d /etc/apt/keyrings
              curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
              sudo chmod a+r /etc/apt/keyrings/docker.gpg

              echo \
                "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
                $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
                sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

              sudo apt-get update -y
              sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
              sudo usermod -aG docker ubuntu
              echo "âœ… Docker installed"
            else
              echo "âœ… Docker already installed: $(docker --version)"
            fi

            # â”€â”€ STEP 2: Start Docker daemon â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            sudo systemctl start docker
            sudo systemctl enable docker
            echo "âœ… Docker daemon running"

            # â”€â”€ STEP 3: Create app folder â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            sudo mkdir -p /opt/myapp/nginx
            sudo chown -R ubuntu:ubuntu /opt/myapp
            cd /opt/myapp

            # â”€â”€ STEP 4: Write nginx config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            cat > /opt/myapp/nginx/nginx.conf << 'NGINXEOF'
            events {}
            http {
              server {
                listen 80;

                location / {
                  proxy_pass http://frontend:3000;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                }

                location /api {
                  proxy_pass http://backend:5000;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                }
              }
            }
            NGINXEOF
            echo "âœ… Nginx config written"

            # â”€â”€ STEP 5: Write docker-compose.yml â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            cat > /opt/myapp/docker-compose.yml << 'COMPOSEEOF'
            services:

              frontend:
                image: FRONTEND_IMAGE_PLACEHOLDER
                restart: always
                networks:
                  - app-network

              backend:
                image: BACKEND_IMAGE_PLACEHOLDER
                restart: always
                environment:
                  DB_HOST: postgres
                  POSTGRES_USER: admin
                  POSTGRES_PASSWORD: POSTGRES_PASSWORD_PLACEHOLDER
                  POSTGRES_DB: appdb
                  REDIS_HOST: redis
                networks:
                  - app-network
                mem_limit: 512m
                cpus: 0.5
                healthcheck:
                  test: ["CMD", "curl", "-f", "http://localhost:5000/health"]
                  interval: 30s
                  timeout: 10s
                  retries: 3

              postgres:
                image: postgres:15
                restart: always
                mem_limit: 512m
                cpus: 0.5
                environment:
                  POSTGRES_USER: admin
                  POSTGRES_PASSWORD: POSTGRES_PASSWORD_PLACEHOLDER
                  POSTGRES_DB: appdb
                volumes:
                  - pgdata:/var/lib/postgresql/data
                networks:
                  - app-network

              redis:
                image: redis:7
                restart: always
                networks:
                  - app-network

              nginx:
                image: nginx:latest
                ports:
                  - "80:80"
                volumes:
                  - ./nginx/nginx.conf:/etc/nginx/nginx.conf
                depends_on:
                  - frontend
                  - backend
                networks:
                  - app-network

            volumes:
              pgdata:

            networks:
              app-network:
            COMPOSEEOF

            # Replace placeholders with actual secret values
            sed -i "s|FRONTEND_IMAGE_PLACEHOLDER|${{ env.IMAGE_FRONTEND }}:latest|g" /opt/myapp/docker-compose.yml
            sed -i "s|BACKEND_IMAGE_PLACEHOLDER|${{ env.IMAGE_BACKEND }}:latest|g" /opt/myapp/docker-compose.yml
            sed -i "s|POSTGRES_PASSWORD_PLACEHOLDER|${{ secrets.POSTGRES_PASSWORD }}|g" /opt/myapp/docker-compose.yml
            echo "âœ… docker-compose.yml written"

            # â”€â”€ STEP 6: Pull latest images from Docker Hub â”€â”€â”€â”€â”€â”€â”€â”€â”€
            sudo docker pull ${{ env.IMAGE_FRONTEND }}:latest
            sudo docker pull ${{ env.IMAGE_BACKEND }}:latest
            echo "âœ… Images pulled"

            # â”€â”€ STEP 7: Start containers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            cd /opt/myapp
            sudo docker compose down --remove-orphans
            sudo docker compose up -d
            echo "âœ… Containers started"

            # â”€â”€ STEP 8: Show running containers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            sleep 5
            sudo docker ps

            # â”€â”€ STEP 9: Cleanup old images â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            sudo docker image prune -f

            echo ""
            echo "ðŸš€ Deployed successfully to AWS EC2!"